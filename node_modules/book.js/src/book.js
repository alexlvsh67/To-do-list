/**
 * @param   {Node}   element
 * @param   {object} options
 * @returns {Book}
 * @constructor
 */
var Book = function (element, options) {
	var self = this;

	// Prevent multiple instantiations.
	if (element.initializedBook) {
		return self;
	}

	self.options = options || {};

	// Note: data attributes take precedence.
	for (var i = 0; i < element.attributes.length; i++) {
		var attribute = element.attributes[i];
		if (/^data-/.test(attribute.nodeName)) {
			var key = attribute.nodeName.replace(/^data-/, '');
			self.options[key] = attribute.nodeValue;
		}
	}

	// We need an image to calculate the sizes.
	if (!self.options.front) {
		return self;
	}

	// Transforms supported?
	self.transforms = self.are3dTransformsSupported();

	self.inner = this.createElement('div', 'book-cover-inner');

	var images = 1, imagesLoaded = 0;
	self.frontImage = self.createElement('img', 'book-cover-front-image', {
		src: self.options.front,
		alt: self.options.frontAlt || ''
	});

	if (!self.transforms) {
		self.inner.appendChild(self.frontImage);
		self.inner.className += ' front';
	}
	else {
		// Wait for the images to load so we can get the correct sizes.
		self.frontImage.onload = function () {
			if (++imagesLoaded === images) {
				self.calculateSizes();
			}
		};

		self.front = self.createElement('div', 'book-cover-front');
		self.frontOutside = self.createElement(
			'div',
			'book-cover-front-outside book-cover-overlay'
		);

		self.frontOutside.appendChild(self.frontImage);
		self.frontInside = self.createElement('div', 'book-cover-front-inside');
		self.front.appendChild(self.frontOutside);
		self.front.appendChild(self.frontInside);
		self.inner.appendChild(self.front);

		self.back = self.createElement('div', 'book-cover-back book-cover-overlay');
		self.inner.appendChild(self.back);

		self.left = self.createElement('div', 'book-cover-left');
		self.inner.appendChild(self.left);

		self.right = self.createElement('div', 'book-cover-right');
		self.inner.appendChild(self.right);

		self.top = self.createElement('div', 'book-cover-top');
		self.inner.appendChild(self.top);

		self.bottom = self.createElement('div', 'book-cover-bottom');
		self.inner.appendChild(self.bottom);

		if (self.options.back) {
			images++;
			self.backImage = self.createElement('img', 'book-cover-back-image', {
				src: self.options.back,
				alt: self.options.backAlt || ''
			});

			self.backImage.onload = function () {
				if (++imagesLoaded === images) {
					self.calculateSizes();
				}
			};

			self.back.appendChild(self.backImage);
		}

		if (self.options.spine) {
			images++;
			self.spineImage = self.createElement('img', 'book-cover-spine-image', {
				src: self.options.spine,
				alt: self.options.spineAlt || ''
			});

			self.spineImage.onload = function () {
				if (++imagesLoaded === images) {
					self.calculateSizes();
				}
			};

			self.left.appendChild(self.spineImage);
		}

		// Need to recalculate whenever the window changes sizes.
		window.addEventListener('resize', self.debounce(function () {
			self.calculateSizes();
		}, 100));
	}

	// Create new element to avoid extra redraws (if one even happens).
	self.element = element.cloneNode();
	self.element.innerHTML = '';
	self.element.appendChild(self.inner);
	self.element.initializedBook = true;

	// Replace old element with the new one.
	element.parentNode.replaceChild(self.element, element);

	return self;
};

/**
 * @return boolean
 */
Book.prototype.are3dTransformsSupported = function () {
	var div = document.createElement('div');
	var inner = document.createElement('div');

	if (div.style.transform === undefined ||
		div.style.transformStyle === undefined) {
		return false;
	}

	div.style.transformStyle = 'preserve-3d';
	div.style.transform = 'rotate3d(0, 1, 0, 35deg)';
	inner.style.transform = 'rotate3d(0, 1, 0, 90deg)';

	div.appendChild(inner);
	document.body.appendChild(div);

	var result = inner.getBoundingClientRect();
	document.body.removeChild(div);

	// If it's zero, then preserve-3d is not working.
	return result.width !== 0;
};

/**
 * @param   {string}           tag
 * @param   {string}           className
 * @param   {object|undefined} attributes
 * @returns {Element}
 */
Book.prototype.createElement = function (tag, className, attributes) {
	var element = document.createElement(tag);
	element.className = className;

	if (attributes) {
		for (var key in attributes) {
			element[key] = attributes[key];
		}
	}

	return element;
};

/**
 * Returns a function that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds.
 *
 * @param  {function} fn
 * @param  {number}   wait In milliseconds.
 * @return {function}
 */
Book.prototype.debounce = function (fn, wait) {
	var timeout;
	return function () {
		clearTimeout(timeout);
		var self = this;
		var args = arguments;
		timeout = setTimeout(function () {
			fn.apply(self, args);
		}, wait);
	};
};

/**
 * Calculate sizes for all the pieces of the book cover.
 */
Book.prototype.calculateSizes = function () {
	// Need to remove our calculated sizes if there were any so we can get the new
	// sizes.
	this.inner.style.height = '';
	this.front.style.height = '';
	this.inner.style.width = '';
	this.front.style.width = '';

	var edgeSpace = 5;
	var height = this.frontImage.offsetHeight;
	var width = this.frontImage.offsetWidth;

	// Set heights.
	this.inner.style.height = height + 'px';
	this.front.style.height = height + 'px';
	this.back.style.height = height + 'px';
	this.left.style.height = height + 'px';
	this.right.style.height = (height - (edgeSpace * 2) + 2) + 'px';
	// +2 because top is 3px instead of 5px which appears to fit better.

	// Set widths.
	this.inner.style.width = width + 'px';
	this.front.style.width = width + 'px';
	this.back.style.width = width + 'px';
	this.bottom.style.width = (width - edgeSpace) + 'px';
	this.top.style.width = (width  - edgeSpace) + 'px';

	// How wide is the spine? Use the image if it exists.
	var spineWidth;
	if (this.spineImage) {
		this.left.style.width = 'auto';
		spineWidth = this.spineImage.offsetWidth;
	}
	else {
		spineWidth = this.left.offsetWidth;
	}
	var spineWidthHalf = spineWidth / 2;

	// Set widths of the page sides to match the width of the spine.
	// -2 helps with clipping through the front and back covers.
	this.top.style.height = (spineWidth - 2) + 'px';
	this.bottom.style.height = (spineWidth - 2) + 'px';
	this.right.style.width = (spineWidth - 2) + 'px'; // -1 helps with clipping.
	this.left.style.width = spineWidth + 'px';

	// Move the sides to the edges.
	this.left.style.left = (-spineWidthHalf) + 'px';
	this.right.style.left = (width - spineWidthHalf - edgeSpace) + 'px';
	this.top.style.top = (-spineWidthHalf + edgeSpace) + 'px';
	this.bottom.style.top = (height - spineWidthHalf - edgeSpace) + 'px';

	// Rotate and push back all the sides and back cover.
	this.back.style.transform = 'rotate3d(0, 1, 0, -180deg) translate3d(0, 0, ' +
		spineWidth + 'px)';
	this.left.style.transform = 'rotate3d(0, 1, 0, -90deg) translate3d(' +
		(-spineWidthHalf) + 'px, 0, 0)';
	this.right.style.transform = 'rotate3d(0, 1, 0, 90deg) translate3d(' +
		spineWidthHalf + 'px, 0, 0)';
	this.top.style.transform = 'rotate3d(1, 0, 0, 90deg) translate3d(0, ' +
		(-spineWidthHalf) + 'px, 0)';
	this.bottom.style.transform = 'rotate3d(1, 0, 0, -90deg) translate3d(0, ' +
		spineWidthHalf + 'px, 0)';
	this.inner.style.transformOrigin = '50% 50% ' + (-spineWidthHalf) + 'px';

	// Set activated and book-cover classes if needed.
	if (!this.activated) {
		if (!/\bbook-cover/.test(this.element.className)) {
			this.element.className += ' book-cover';
		}
		if (!/\activated/.test(this.element.className)) {
			this.element.className += ' activated';
		}
		this.element.className = this.element.className.trim();
		this.activated = true;
		this.inner.className += ' hover-ok';
	}

	// Show hidden images.
	this.spineImage.style.visibility = 'visible';
	this.backImage.style.visibility = 'visible';
};

/**
 * Toggle flipped class on the inner book cover element.
 */
Book.prototype.flip = function () {
	if (this.transforms) {
		// Disable hover while flipping.
		this.inner.className = this.inner.className
			.replace(/hover-ok/g, '').trim();
		clearTimeout(this.timeout);

		if (/flipped/.test(this.inner.className)) {
			this.inner.className = this.inner.className
				.replace(/flipped/g, '').trim();
		}
		else {
			this.inner.className += ' flipped';
		}

		var self = this;
		this.timeout = setTimeout(function () {
			self.inner.className += ' hover-ok';
		}, 500);
	}
	else if (this.options.back) {
		if (/front/.test(this.inner.className)) {
			this.inner.className = this.inner.className
				.replace(/front/g, 'back').trim();
			this.frontImage.src = this.options.back;
			this.frontImage.alt = this.options.backAlt || '';
		}
		else {
			this.inner.className = this.inner.className
				.replace(/back/g, 'front').trim();
			this.frontImage.src = this.options.front;
			this.frontImage.alt = this.options.frontAlt || '';
		}
	}
};

if (typeof jQuery !== 'undefined') {
	jQuery.fn.book = function (options) {
		var instances = [];

		for (var i = 0; i < this.length; i++) {
			instances.push(new Book(this[i], options));
		}

		return instances.length === 1 ? instances[0] : instances;
	};
}
